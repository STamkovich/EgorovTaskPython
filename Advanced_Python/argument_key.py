# 10.7 Сортировка по ключу Python. Аргумент key
# аргумент key в сортировке

a = [4, -10, 43, -300, 54, 289, -34, -8, 749]
print(sorted(a))  # [-300, -34, -10, -8, 4, 43, 54, 289, 749]
# первый способ сортировки по ключу это передать встроенную функцию
print(sorted(a, key=abs))  # [4, -8, -10, -34, 43, 54, 289, -300, 749]


# так же мы можем передавать собственные функции
def f(x):
    return x % 10  # что бы выполнить сортировку в обратно порядке -(x % 10)


print(sorted(a, key=f))  # [-10, -300, -8, 43, 4, 54, -34, 289, 749] сортируем по последней цифре


#  способ когда можно сортировать по двум критериям
def f(x):
    return x % 10, x // 10 % 10


print(sorted(a, key=f))  # [-300, -10, -8, 43, 4, 54, -34, 749, 289] сортировка по последней цифре либо по предпоследней

# третий способ сортировки по встроенным метода объекта
c = ['ZZZ', 'aaa', 'eee', 'DDD', 'BBB', 'www']  # сортируем этот список по алфавиту не смотря на регистр букв
print(sorted(c, key=str.lower))  # ['aaa', 'BBB', 'DDD', 'eee', 'www', 'ZZZ']
# четвёртый способ сортировки с использованием анонимных функций lambda
d = ['ZZZ 79', 'aaa 45', 'eee 43', 'DDD 800', 'BBB 5', 'www 14']
print(sorted(d, key=lambda x: int(x.split()[1])))  # ['BBB 5', 'www 14', 'eee 43', 'aaa 45', 'ZZZ 79', 'DDD 800']
# двойная сортировка при помощи lambda
e = ['ZZZ 800', 'aaa 45', 'eee 43', 'DDD 800', 'BBB 45', 'www 14']
print(sorted(e, key=lambda x: (int(x.split()[1]), x.split()[0].lower())))
# ['www 14', 'eee 43', 'BBB 45', 'aaa 45', 'DDD 800', 'ZZZ 800']

# Сортировка словаря по ключам и значениям
heroes = {
    'spider-Man': 80,
    'Batman': 65,
    'Superman': 85,
    'Wonder Woman': 70,
    'Flash': 70,
    'Iron Man': 65,
    'Thor': 90,
    'Aquaman': 65,
    'Captain America': 65,
    'Hulk': 87,
}
for i in sorted(heroes): # сортировка по ключу
    print(i, heroes[i])

for i in sorted(heroes.values()):  # сортировка по значению
    print(i)
# а что бы отсортировать по значению и видеть ещё ключ нужно так
# тут будет сортировка по ключу то есть в алфавитном порядке
for i in sorted(heroes.items()):  # метод items возвращает пары в виде кортежа в котором храниться ключ значение
    print(i)
# что бы сортировалось по значению то
for i in sorted(heroes.items(), key=lambda para: para[1]):
    print(i)

# в если после сортировки по значению вы хотите ещё отсортировать по алфавиту
# при одинаковых значениях то
for i in sorted(heroes.items(), key=lambda para: (para[1], para[0])):
    print(i)

# задачки
# Напишите программу, которая отсортирует список subject_marks по возрастаю оценок.
# Затем распечатайте предметы и оценки, каждый пару на новой строчке через пробел
subject_marks = [('English', 88), ('Science', 90), ('Maths', 97), ('Physics', 93),('History', 82)]
new_subject_marks = sorted(subject_marks, key=lambda x: x[1])
for i in new_subject_marks:
    print(*i)
# Напишите программу, которая отсортирует список subject_marks по убыванию оценок.
# Затем распечатайте предметы и оценки, каждый пару на новой строчке через пробел
subject_marks = [('English', 88), ('Science', 90), ('Maths', 97),
                 ('Physics', 93), ('History', 82), ('French', 78),
                 ('Art', 58), ('Chemistry', 76), ('Programming', 91)]
new_subject_marks = sorted(subject_marks, key=lambda x: x[1], reverse=True)
for i in new_subject_marks:
    print(*i)

# Напишите программу, которая отсортирует список subject_marks по убыванию оценок. Предметы, имеющих одинаковые оценки,
# должны быть отсортированы в алфавитном порядке
# Затем распечатайте предметы и оценки, каждый пару на новой строчке через пробел
subject_marks = [('English', 88), ('Science', 90), ('Maths', 88),
                 ('Physics', 93), ('History', 78), ('French', 78),
                 ('Art', 78), ('Chemistry', 88), ('Programming', 91)]
new_subject_marks = sorted(subject_marks, key=lambda x: (-x[1],  x[0]))
for i in new_subject_marks:
    print(*i)

# Напишите программу, которая отсортирует список models по цвету в лексикографическом порядке (по алфавиту)
# Затем распечатайте элементы этого списка, каждый элемент на новой строке в формате:
# Производитель: <make>, модель: <model>, цвет: <color>
models = [{'make': 'Nokia', 'model': 216, 'color': 'Black'},
          {'make': 'Mi Max', 'model': 2, 'color': 'Gold'},
          {'make': 'Samsung', 'model': 7, 'color': 'Blue'},
          {'make': 'Apple', 'model': 10, 'color': 'Silver'},
          {'make': 'Oppo', 'model': 9, 'color': 'Red'},
          {'make': 'Huawei', 'model': 4, 'color': 'Grey'},
          {'make': 'Honor', 'model': 3, 'color': 'Black'}]

new_models = sorted(models, key=lambda x: x['color'])
for i in new_models:
    print(f'Производитель: {i["make"]}, модель: {i["model"]}, цвет: {i["color"]}')


# Представьте, у нас есть список товаров и их стоимость, но мы хотим взглянуть на него в отсортированном виде.
# Вверху хотим видеть самые дорогие товары, внизу самые дешевые
# Программа будет принимать строки, в которых сперва указывается название товара,
# а затем через двоеточие с пробелом его цена - целое положительное число.
# Строка "конец" означает списка товаров и соответственно окончание ввода
# Все товары имеют уникальные названия, цены не дублируются.
# Ваша задача вывести список товаров поe уменьшению цены
sp = []
while True:
    products = input()
    if products == 'конец':
        break
    sp.append(products)

price = {device: int(price) for device, price in map(lambda item: item.split(':'), sp)}
a = sorted(price.items(), key=lambda kv: (kv[1], kv[0]))
for device, _ in sorted(price.items(), key=lambda kv: (-kv[1], kv[0])):
    print(device)

# Премия Оскар
# Представьте, что мы с вами сами можем решать кому и сколько статуэток Оскара уйдет
# (Лео бы тогда давно купался в этих статуэтках)
# Ваша задача написать программу, которая находит информацию,
# кто из актеров получил наибольшее и наименьшее количество статуэток
# Входные данные
# Программа принимать на вход в первой строке натуральное число n - количество вручаемых сегодня наград.
# И затем в n следующих строках вводятся имена актеров - победителей.
# Выходные данные
# Нужно вывести в  отдельных строках имена актеров набравших наибольшее и наименьшее количество статуэток
# и через запятую их количество. Гарантируется, что всегда будет только один человек, набравших наибольшее
# и наименьшее количество статуэток.
actors_dict = {}
count_reward = int(input())
for i in range(count_reward):
    actors = input()
    if actors in actors_dict:
        actors_dict[actors] += 1
        actors_dict.setdefault(actors, i)
    else:
        actors_dict.setdefault(actors, i)
        actors_dict[actors] = 1
for i in sorted(actors_dict.items(), key=lambda para: -para[1]):
    break
print(f'{max(actors_dict, key=actors_dict.get)}, {max(actors_dict.values())}')
print(f'{min(actors_dict, key=actors_dict.get)}, {min(actors_dict.values())}')
# второй вариант
reward = int(input(f'Ведите количество статуэток: '))
actors_dict = {}
count = 0
count_reward = 0

while count != reward:
    actors = input(f'Введите актёров, которые номинируются на статуэтку: ')
    actors_dict.setdefault(actors, 0)
    actors_dict[actors] += 1
    count += 1
print(f'{max(actors_dict, key=actors_dict.get)}, {max(actors_dict.values())}')
print(f'{min(actors_dict, key=actors_dict.get)}, {min(actors_dict.values())}')
# Телефонная книга
# Петя очень популярный парень, у него много друзей и он хочет сохранить их контакты в телефонной книге.
# Известно, что у каждого друга может быть один или больше номеров телефонов.
# Напишите программу, которая поможет Пете находить все номера определённого друга.
# Формат ввода
# В первой строке задано одно целое число N (1 ≤ N ≤ 1000) — количество номеров телефонов,
# информацию о которых Петя  решил сохранить в телефонной книге.
# В следующих N строках заданы телефоны и имена их владельцев через пробел.
# Телефон — это несколько цифр, записанных подряд, имя же состоит только из русских букв. Записи не повторяются.
# В следующей строке записано целое число M (1 ≤ M ≤ 100) — количество запросов от Пети.
# В следующих M строках записаны сами запросы, по одному на строке. Каждый запрос — это имя какого-то друга,
# чьи телефоны Петя хочет сейчас найти, записанное в точности так, как в телефонной книге.
# Формат вывода
# Для каждого запроса от Пети выведите в отдельной строке все телефоны, принадлежащие человеку с этим именем.
# Телефоны одного человека выводите в одну строку через пробел в том порядке,в котором они были заданы во входных данных
# Если в телефонной книге нет телефонов человека с таким именем,
# выведите в соответствующей строке «Неизвестный номер» (без кавычек).
count_numbers = int(input())
lis_numbers = {}
for i in range(count_numbers):
    number, name = input().split()
    if name in lis_numbers:
        lis_numbers[name].append(number)
    else:
        lis_numbers[name] = [number]

inquiry = int(input())
for i in range(inquiry):
    name = input()
    if name in lis_numbers:
        print(*lis_numbers[name])
    else:
        print('Неизвестный номер')
# Дни рождения
# У Игоря N одноклассников. Игорь не смог запомнить их дни рождения и решил составить календарь дней рождений класса.
# По известному списку всех дней рождения научитесь определять, у кого день рождения в заданном месяце.
# Формат ввода
# В первой строчке записано целое число N (1 ≤ N ≤ 1000) — количество одноклассников Игоря.
# В следующих N строчках записана информация об их днях рождения. Каждая строчка состоит из трёх частей,
# разделённых пробелом — имени одноклассника, дня и месяца его рождения.
# Имя — это строка из русских букв, день — число от 1 до 31, а месяц — строка из набора «янв», «фев», «мар»,
# «апр», «май», «июн», «июл», «авг», «сен», «окт», «ноя», «дек».
# Имена всех одноклассников Игоря различны.
# В следующей строчке записано целое число M (1 ≤ M ≤ 100) — количество вопросов, на которое надо ответить.
# В следующих M строках содержатся сами вопросы.
# Вопрос — это название месяца в том же формате, в котором они задаются выше.
# Формат вывода
# Для каждого вопроса в отдельной строчке через пробел выведите имена всех одноклассников,
# которые родились в указанном месяце. Имена упорядочьте в лексикографическом порядке.
# Если в заданном месяце никто не родился, выведите сообщение "Нет данных".
count_people = int(input())
dic_people = {}
for i in range(count_people):
    name, birth_number, birth_month = input().split()
    if birth_month in dic_people:
        dic_people[birth_month].append(name)
    else:
        dic_people[birth_month] = [name]


count_people = int(input())
for i in range(count_people):
    month = input()
    if month in dic_people:
        print(*sorted(dic_people[month]))
    else:
        print('Нет данных')
# второй пример
dr = {}

for _ in range(int(input())):
    name, _, month = input().split()
    dr.setdefault(month, []).append(name)

for _ in range(int(input())):
    print(*sorted(dr.get(input(), ['Нет данных'])))
# Рейтинг таксистов
# Руководитель таксопарка хочет увидеть отчет по всем таксистам, где нужно указать имя таксиста и его среднюю оценку.
# Информацию в отчете нужно расположить по убыванию средней оценки таксиста.
# После каждого успешно выполненного заказа, клиент выставляет таксисту оценку - целое число от 1 до 5.
# Входные данные
# Программа будет принимать строки, в которых сперва указывается имя таксиста,
# а затем через запятую с пробелом его оценка за заказ.
# Строка "конец" является последней строкой и означает окончание ввода
# Выходные данные
# Нужно расположить таксистов в порядке убывания их средней оценке
# и вывести имя каждого таксиста и его среднюю оценку в отдельной строке.
# В случае совпадения средних оценок расположить таксистов нужно отсортировать имена таксистов по алфавиту
dic_people = {}

while True:
    name_grade = input().split(', ')
    if name_grade[0] == 'конец':
        break
    dic_people.setdefault(name_grade[0], []).append(int(name_grade[1]))

for i, j in sorted(dic_people.items(), key=lambda x: (-sum(x[1]) / len(x[1]), x[0])):
    print(i, sum(j) / len(j))
