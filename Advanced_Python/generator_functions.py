# 10.2 Функция генератор. Создание генератора при помощи yield

# Давайте вспомним как работает обычная функция
def f():
    return [1, 3, 4, 5]


# при вызове функции generator() – нам разом вернется список [1,3,4,5], но функция генератор представляет из себя
# функцию которая запоминаем на каком объекте происходила итерация и возвращает элементы по одному.
# Чтобы написать такую функцию смотрите ниже:

def generator():
    for i in range(1, 6):
        yield i  # – yield это ключевое слово для генератора


# давайте сохраним функцию в переменную а:
a = generator()
# Теперь мы можем обращаться к нашей переменной а (которая хранит функцию генератор) через функцию next
print(next(a))  # – такой вызов будет возвращать по одному элементу из указанных в функции range(1,6)


# Так как эта функция – генератор. Элементы ее можно обойти только один раз!
# Еще раз о ключевом слове yield – Она в буквально смысле замораживает функцию на том месте где она вызывалась
# и если у вас после нее есть код то он выполнится только при следующем вызове функции:

def sayGenerator():
    e = 'like'
    for i in range(5):
        yield i
        print(e)


e = sayGenerator()  # – сохраняем функцию в переменную а
print(next(e))  # – при первом вызове мы выполним итерацию цикла for и выведется цифра 0
print(next(e))  # – это второй вызов и так как в первом вызове мы вывели число с цикла for


# а после него шло ключевое слово yield – оно заморозило функцию и при втором вызове
# функцию продолжит выполнять код уже после выполнения первой итерации цикла – то есть выведется like
# Где такая функция генератор может понадобится?
# Например мы делаем функцию factorial которая находит факториал числа от 2 до n – n укажет пользователь.
# Факториалы мы будем записывать в список и вернем их сразу.

def factorial(x):  # – факториал с аргументом х – от 0 до x+1
    pr = 1  # – переменная в которой будут считаться факториалы.
    c = []  # – список в котором будут храниться факториалы
    for i in range(1, x + 1):  # почему с двух? Умножать 1 на 1 нет смысла.
        pr = pr * i  # – записываем в пр факториал.
        c.append(pr)  # – записываем факториал в список
    return c  # – возвращаем все факториалы числа x


# Теперь функция вернет список в котором хранятся факториалы числа x.
# Но этот список будет занимать место в памяти. И это можно решить функцией генератором

def factorialGenerator(x):  # – функция генератор факториал.
    pr = 1  # – переменная в которую записывается факториал
    for i in range(1, x + 1):  # обходим все цифры от 2 до х + 1
        pr = pr * i  # – записываем факториал в pr
        yield pr  # – возвращаем факториал i числа.

# s = factorialGenerator(10)
# print(next(s))
# но мы можем обойти циклом for
for i in factorialGenerator(10):
    print(i, end=' ') # end= ' ' - отменяем перенос строки
# Теперь наша функция будет возвращать факториал от 2 до x и она итерабельна, то есть можно к ней вызывать функцию next.
# И самое главное она не занимает места в памяти.
