# Вложенные списки
a = [[0, 2, 4, 6], [1, 5, 9, 13], [3, 10, [3, 4, 5], 7, 19]]
print(a[2][2][1])

a = [[0, 2, 4, 6], [1, 5, 9, 13], [3, 10, 17, 19]]
b = ['hell', 'hi', 'world']
print(b[2][0])
a = [
    [0, 2, 4, 6],
    [1, 5, 9, 13],
    [3, 10, 17, 19]
]
# первый вариант обхода списков (обход по значениям)
for i in a:
    for j in i:
        print(j, end=' ')
    print()
# обход по индексам
a = [
    [0, 2, 4, 6],
    [1, 5, 9, 13],
    [3, 10, 17, 19]
]
for i in range(3):
    for j in range(4):
        a[i][j] += 10
        print(a[i][j], end=' ')
    print()
print(a)
# при таком вариенте обхода можно менгять значение элементов
# обход по индексам в обратном порядке
a = [
    [0, 2, 4, 6],
    [1, 5, 9, 13],
    [3, 10, 17, 19]
]
for i in range(2, -1, -1):
    for j in range(3, -1, -1):
        a[i][j] += 10
        print(a[i][j], end=' ')
    print()
print(a)
#   нахождение суммы по строкам
for i in range(3):
    s = 0
    for j in range(4):
        s += a[i][j]
    print(s)
# нахождение суммы по столбцам
for j in range(4):
    s = 0
    for i in range(3):
        s += a[i][j]
    print(s)
    # обход по индексам в обратном порядке
    a = [
        [0, 2, 4, 6],
        [1, 5, 9, 13],
        [3, 10, 17, 19]
    ]
    for i in range(2, -1, -1):
        for j in range(3, -1, -1):
            a[i][j] += 10
            print(a[i][j], end=' ')
        print()
    print(a)
# заполнение вложенного списка
a = []
n = int(input())
m = int(input())
for i in range(n):
    a.append([0]*m)
for i in a:
    print(i)
# заполнение вложенного списка
a = []
n = int(input())
m = int(input())
for i in range(n):
    b = []
    for j in range(m):
        b.append(int(input()))
    a.append(b)
for i in a:
    print(i)

a = []
n = int(input())
for i in range(n):
    a.append([0] * n)
for i in range(n):
    for j in range(n):
        if i == j:
            a[i][j] = 10
        elif i > j:
            a[i][j] = 3
        else:
            a[i][j] = 5
for i in a:
    print(i)
# задачки
# Вам нужно посчитать сумму элементов двумерного квадратного (NxN) списка, которые расположены на главной диагонали.
# Под главной диагональю матрицы подразумевается диагональ, проведённая из левого верхнего угла в правый нижний.
# Программа сперва принимает на вход число N (N<=15) - количество строк и столбцов в списке,
# а затем в N строках записаны элементы списка.
a = []
n = int(input())
s = 0
for i in range(n):
    a.append(list(map(int, input().split())))
    for j in range(n):
        if i == j:
            s += a[i][j]
print(s)
# Обход элементов матрицы - 1
# Задана целочисленная квадратная матрица размером N x N.
# Необходимо обойти элементы этой матрицы сверху вниз слева направо и вывести элементы именно в таком порядке
# в виде таблицы.
# Программа принимает на вход натуральное число N – количество строк и столбцов матрицы.
# В каждой из последующих N строк записаны N целых чисел – элементы матрицы.
# Все числа во входных данных не превышают 100 по абсолютной величине.
n = int(input())
a = []
for i in range(n):
    a.append(list(map(int, input().split())))
for j in range(n):
    for i in range(n):
        print(a[i][j], end=' ')
    print()
# Обход элементов матрицы - 2
# Задана целочисленная квадратная матрица размером N x N.
# Необходимо обойти элементы этой матрицы снизу вверх справо налево и вывести элементы именно
# в таком порядке в виде таблицы.
# Программа принимает на вход натуральное число N – количество строк и столбцов матрицы.
# В каждой из последующих N строк записаны N целых чисел – элементы матрицы.
n = int(input())
a = []
for i in range(n):
    a.append(list(map(int, input().split())))
for j in range(n - 1, -1, -1):
    for i in range(n - 1, -1, -1):
        print(a[i][j], end=' ')
    print()
# Обход элементов матрицы - 3
# Задана целочисленная матрица, состоящая из N строк и M столбцов.
# Необходимо обойти элементы этой матрицы cправо налево сверху вниз и вывести элементы именно
# в таком порядке в виде таблицы.
# Программа принимает на вход два натуральных числа N и M – количество строк и столбцов матрицы.
# В каждой из последующих N строк записаны M целых чисел – элементы матрицы.
n, m = map(int, input().split())
a = []
for i in range(n):
    a.append(list(map(int, input().split())))
for i in range(n):
    for j in range(m - 1, -1, -1):
        print(a[i][j], end=' ')
    print()
# Обход элементов матрицы - 4
# Задана целочисленная матрица, состоящая из N строк и M столбцов.
# Необходимо обойти элементы этой матрицы слева направо снизу вверх и вывести элементы именно
# в таком порядке в виде таблицы.
# Программа принимает на вход два натуральных числа N и M – количество строк и столбцов матрицы.
# В каждой из последующих N строк записаны M целых чисел – элементы матрицы.
n, m = map(int, input().split())
a = []
for i in range(n):
    a.append(list(map(int, input().split())))
for i in range(n - 1, -1, -1):
    for j in range(m):
        print(a[i][j], end=' ')
    print()
# A. Красивая матрица
# Перед Вами матрица размера 5 × 5, состоящая из 24-x нулей и единственной единицы.
# Строки матрицы пронумеруем числами от 1 до 5 сверху вниз, столбцы матрицы пронумеруем числами от 1 до 5 слева направо.
# За один ход разрешается применить к матрице одно из двух следующих преобразований:
# Поменять местами две соседние строки матрицы,
# то есть строки с номерами i и i + 1 для некоторого целого i (1 ≤ i < 5).
# Поменять местами два соседних столбца матрицы,
# то есть столбцы с номерами j и j + 1 для некоторого целого j (1 ≤ j < 5).
# Вы считаете, что матрица будет выглядеть красиво,
# если единственная единица этой матрицы будет находиться в ее центре
# (в клетке, которая находится на пересечении третьей строки и третьего столбца).
# Посчитайте, какое минимальное количество ходов потребуется, чтобы сделать матрицу красивой.
# Входные данные
# Входные данные состоят из пяти строк, в каждой из которых записаны пять целых чисел:
# j-ое число в i-ой строке входных данных обозначает элемент матрицы, стоящий на пересечении i-ой строки и j-ого столбца
# Гарантируется, что матрица состоит из 24-x нулей и единственной единицы.
# Выходные данные
# Выведите единственное целое число — минимальное количество действий, которое требуется, чтобы сделать матрицу красивой
a = []
for i in range(5):
    a.append(list(map(int, input().split())))
for i in range(5):
    for j in range(5):
        if a[i][j] == 1:
            r = i
            c = j
print(abs(2 - r) + abs(2 - c))
# Сумма строк и столбцов двумерного массива
# Задан целочисленный двумерный массив, состоящий из N строк и M столбцов.
# Требуется вычислить сумму элементов в каждой строке и в каждом столбце.
# Программа получает на вход два натуральных числа N и M – количество строк и столбцов двумерного массива.
# В каждой из последующих N строк записаны M целых чисел – элементы массива.
# Все числа во входных данных не превышают 1000 по абсолютной величине.
# В первой строке вам необходимо вывести N чисел – суммы элементов массива для каждой строки в отдельности.
# Во второй строке в аналогичном формате выведите M чисел – суммы элементов для каждого столбца.
n, m = map(int, input().split())
a = []
for i in range(n):
    a.append(list(map(int, input().split())))
for i in range(n):
    s = 0
    for j in range(m):
        s += a[i][j]
    print(s, end=' ')
print()
for e in range(m):
    c = 0
    for r in range(n):
        c += a[r][e]
    print(c, end=' ')
# Симметричная ли матрица?
# Проверьте, является ли двумерный массив симметричным относительно главной диагонали.
# Главная диагональ — та, которая идёт из левого верхнего угла двумерного массива в правый нижний.
# Входные данные
# Программа получает на вход число n<100, являющееся числом строк и столбцов в массиве.
# Далее во входном потоке идет n строк по n чисел, являющихся элементами массива.
# Выходные данные
# Программа должна выводить слово Yes для симметричного массива и слово No для несимметричного.
n = int(input())
a = []
sim = True
for i in range(n):
    a.append(list(map(int, input().split())))
for i in range(n):
    for j in range(n):
        if a[i][j] != a[j][i]:
            sim = False
if sim:
    print("Yes")
else:
    print("No")
# Состязания
# В метании молота состязается n спортcменов. Каждый из них сделал m бросков.
# Победителем считается тот спортсмен, у которого сумма результатов по всем броскам максимальна.
# Если перенумеровать спортсменов числами от 0 до n-1, а попытки каждого из них – от 0 до m-1,
# то на вход программа получает массив A[n][m], состоящий из неотрицательных целых чисел.
# Программа должна определить максимальную сумму чисел в одной строке и вывести на экран эту сумму и номер строки,
# для которой достигается эта сумма.
# Входные данные
# Программа получает на вход два числа n и m, являющиеся числом строк и столбцов в массиве.
# Далее во входном потоке идет n строк по m чисел, являющихся элементами массива.
# Выходные данные
# Программа должна вывести  2 числа: сумму и номер строки, для которой эта сумма достигается. Если таких строк несколько
# то выводится номер наименьшей из них. Не забудьте, что нумерация строк (спортсменов) начинается с 0.
n, m = map(int, input().split())
a = []
b = []
for i in range(n):
    a.append(list(map(int, input().split())))
for i in range(n):
    s = 0
    for j in range(m):
        s += a[i][j]
    b.append(s)
print(max(b))
print(b.index(max(b)))
# Состязания - 2
# В метании молота состязается n спортcменов. Каждый из них сделал m бросков.
# Победителем соревнований объявляется тот спортсмен, у которого максимален наилучший результат по всем броскам.
# Таким образом, программа должна найти значение максимального элемента в данном массиве,
# а также его индексы (то есть номер спортсмена и номер попытки).
# Входные данные
# Программа получает на вход два числа n и m, являющиеся числом строк и столбцов в массиве.
# Далее во входном потоке идет n строк по m чисел, являющихся элементами массива.
# Выходные данные
# Программа выводит значение максимального элемента, затем номер строки и номер столбца, в котором он встречается.
# Если в массиве несколько максимальных элементов, то нужно вывести минимальный номер строки,
# в которой встречается такой элемент, а если в этой строке таких элементов несколько,
# то нужно вывести минимальный номер столбца.
# Не забудьте, что все строки и столбцы нумеруются с 0.
n, m = map(int, input().split())
a = []
stroki = n
stolb = m
maxi = 0
for i in range(n):
    a.append(list(map(int, input().split())))
for i in range(n):
    for j in range(m):
        if a[i][j] > maxi:
            maxi = a[i][j]
            stroki = i
            stolb = j
print(maxi)
print(stroki, stolb)
# Состязания - 3
# В метании молота состязается n спортcменов. Каждый из них сделал m бросков.
# Побеждает спортсмен, у которого максимален наилучший бросок. Если таких несколько,
# то из них побеждает тот, у которого наилучшая сумма результатов по всем попыткам.
# Если и таких несколько, победителем считается спортсмен с минимальным номером.Определите номер победителя соревнований
# Входные данные
# Программа получает на вход два числа n и m, являющиеся числом строк и столбцов в массиве.
# Далее во входном потоке идет n строк по m чисел, являющихся элементами массива.
# Выходные данные
# Программа должна вывести одно число - номер победителя соревнований.
# Не забудьте, что  строки(спортсмены) нумеруются с 0
a = []
n, m = map(int, input().split())
for i in range(n):
    a.append(list(map(int, input().split())))

maxi_schet = 0
summ_str = 0
max_index = 0

for i in range(n):
    max_br = 0
    max_str = 0
    for j in range(m):
        max_str += a[i][j]
        if a[i][j] > max_br:
            max_br = a[i][j]

    if max_br > maxi_schet:
        maxi_schet = max_br
        summ_str = max_str
        max_index = i
    elif maxi_schet == max_br and max_str > summ_str:
        maxi_schet = max_br
        summ_str = max_str
        max_index = i
print(max_index)
# Состязания - 4
# В метании молота состязается n спортcменов.
# Каждый из них сделал m бросков.
# Победитель определяется по лучшему результату.
# Определите количество участников состязаний, которые разделили первое место,
# то есть определите количество строк в массиве, которые содержат значение, равное наибольшему.
# Входные данные
# Программа получает на вход два числа n и m, являющиеся числом строк и столбцов в массиве.
# Далее во входном потоке идет n строк по m чисел, являющихся элементами массива.
# Выходные данные
# Программа должна вывести  одно число - количество победителей соревнования.
a = []
n, m = map(int, input().split())
for i in range(n):
    a.append(list(map(int, input().split())))

count = 0
max_br = 0
for i in range(n):
    for j in range(m):
        if a[i][j] > max_br:
            max_br = a[i][j]
for i in a:
    if max_br in i:
        count += 1
print(count)
# Симпатичный узор
# На днях Иван у себя в прихожей выложил кафель, состоящий из квадратных черных и белых плиток.
# Прихожая Ивана имеет квадратную форму 4х4, вмещающую 16 плиток. Теперь Иван переживает, что узор из плиток,
# который у него получился, может быть не симпатичным. С точки зрения дизайна симпатичным узором считается тот,
# который не содержит в себе квадрата 2х2, состоящего из плиток одного цвета.
# Примеры возможных узоров:
# Симпатичный узор
# По заданному расположению плиток в прихожей Ивана требуется определить: является ли выполненный узор симпатичным.
# Программе поступает на вход 4 строки по 4 символа «W» или «B» в каждой, описывающие узор из плиток.
# Символ «W» обозначает плитку белого цвета, а «B» - черного.
# Ваша задача вывести «Yes», если узор является симпатичным и «No» в противном случае
a = []
sim = True
for i in range(4):
    a.append(list(input()))
for i in range(3):
    for j in range(3):
        if a[i][j] == a[i + 1][j] == a[i][j + 1] == a[i + 1][j + 1]:
            sim = False
if sim:
    print("Yes")
else:
    print("No")
# Миша и негатив
# Миша уже научился хорошо фотографировать и недавно увлекся программированием. Первая программа, которую он написал,
# позволяет формировать негатив бинарного черно-белого изображения.
# Бинарное черно-белое изображение – это прямоугольник, состоящий из пикселей, каждый из которых может быть либо черным,
# либо белым. Негатив такого изображения получается путем замены каждого черного пикселя на белый,
# а каждого белого пикселя – на черный.
# Миша, как начинающий программист, написал свою программу с ошибкой,
# поэтому в результате ее исполнения мог получаться некорректный негатив.
# Для того чтобы оценить уровень несоответствия получаемого негатива исходному изображению,
# Миша начал тестировать свою программу.
# В качестве входных данных он использовал исходные изображения.
# Сформированные программой негативы он начал тщательно анализировать,
# каждый раз определяя число пикселей негатива, которые получены с ошибкой.
# Требуется написать программу, которая в качестве входных данных использует исходное бинарное черно-белое изображение и
# полученный Мишиной программой негатив, и на основе этого определяет количество пикселей, в которых допущена ошибка.
# Программа сперва считывает числа n и m (1 ≤ n, m ≤ 100) – высоту и ширину исходного изображения (в пикселях).
# Последующие n строк содержат описание исходного изображения. Каждая строка состоит из m символов «B» и «W».
# Символ «B» соответствует черному пикселю, а символ «W» – белому. Далее следует пустая строка,
# а после нее – описание выведенного Мишиной программой изображения в том же формате, что и исходное изображение.
# Необходимо вывести на экран число пикселей негатива, которые неправильно сформированы Мишиной программой.
n, m = map(int, input().split())
a = []
b = []
count = 0
for i in range(n):
    a.append(input())
input()
for i in range(n):
    b.append(input())
for i in range(n):
    for j in range(m):
        if a[i][j] == b[i][j]:
            count += 1
print(count)
# A. Таблица умножения
# Рассмотрим таблицу из n строк и n столбцов.
# Известно, что в клетке, образованной пересечением i-й строки и j-го столбца
# записано число i × j. Строки и столбцы нумеруются с единицы.
# Дано целое положительное число x. Требуется посчитать количество клеток таблицы, в которых находится число x.
# Входные данные
# В единственной строке находятся числа n и x (1 ≤ n ≤ 105, 1 ≤ x ≤ 109) — размер таблицы и число,
# которое мы ищем в таблице.
# Выходные данные
# Выведите единственное число: количество раз, которое число x встречается в таблице.
n, x = map(int, input().split())
count = 0
for i in range(1, n + 1):
    for j in range(1, n + 1):
        if i * j == x:
            count += 1
print(count)
