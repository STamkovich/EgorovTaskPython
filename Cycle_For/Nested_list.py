# Вложенные списки
a = [[0, 2, 4, 6], [1, 5, 9, 13], [3, 10, [3, 4, 5], 7, 19]]
print(a[2][2][1])

a = [[0, 2, 4, 6], [1, 5, 9, 13], [3, 10, 17, 19]]
b = ['hell', 'hi', 'world']
print(b[2][0])
a = [
    [0, 2, 4, 6],
    [1, 5, 9, 13],
    [3, 10, 17, 19]
]
# первый вариант обхода списков (обход по значениям)
for i in a:
    for j in i:
        print(j, end=' ')
    print()
# обход по индексам
a = [
    [0, 2, 4, 6],
    [1, 5, 9, 13],
    [3, 10, 17, 19]
]
for i in range(3):
    for j in range(4):
        a[i][j] += 10
        print(a[i][j], end=' ')
    print()
print(a)
# при таком вариенте обхода можно менгять значение элементов
# обход по индексам в обратном порядке
a = [
    [0, 2, 4, 6],
    [1, 5, 9, 13],
    [3, 10, 17, 19]
]
for i in range(2, -1, -1):
    for j in range(3, -1, -1):
        a[i][j] += 10
        print(a[i][j], end=' ')
    print()
print(a)
#   нахождение суммы по строкам
for i in range(3):
    s = 0
    for j in range(4):
        s += a[i][j]
    print(s)
# нахождение суммы по столбцам
for j in range(4):
    s = 0
    for i in range(3):
        s += a[i][j]
    print(s)
    # обход по индексам в обратном порядке
    a = [
        [0, 2, 4, 6],
        [1, 5, 9, 13],
        [3, 10, 17, 19]
    ]
    for i in range(2, -1, -1):
        for j in range(3, -1, -1):
            a[i][j] += 10
            print(a[i][j], end=' ')
        print()
    print(a)
# заполнение вложенного списка
a = []
n = int(input())
m = int(input())
for i in range(n):
    a.append([0] * m)
for i in a:
    print(i)
# заполнение вложенного списка
a = []
n = int(input())
m = int(input())
for i in range(n):
    b = []
    for j in range(m):
        b.append(int(input()))
    a.append(b)
3

a = []
n = int(input())
for i in range(n):
    a.append([0] * n)
for i in range(n):
    for j in range(n):
        if i == j:
            a[i][j] = 10
        elif i > j:
            a[i][j] = 3
        else:
            a[i][j] = 5
for i in a:
    print(i)
# задачки
# Вам нужно посчитать сумму элементов двумерного квадратного (NxN) списка, которые расположены на главной диагонали.
# Под главной диагональю матрицы подразумевается диагональ, проведённая из левого верхнего угла в правый нижний.
# Программа сперва принимает на вход число N (N<=15) - количество строк и столбцов в списке,
# а затем в N строках записаны элементы списка.
a = []
n = int(input())
s = 0
for i in range(n):
    a.append(list(map(int, input().split())))
    for j in range(n):
        if i == j:
            s += a[i][j]
print(s)
# Обход элементов матрицы - 1
# Задана целочисленная квадратная матрица размером N x N.
# Необходимо обойти элементы этой матрицы сверху вниз слева направо и вывести элементы именно в таком порядке
# в виде таблицы.
# Программа принимает на вход натуральное число N – количество строк и столбцов матрицы.
# В каждой из последующих N строк записаны N целых чисел – элементы матрицы.
# Все числа во входных данных не превышают 100 по абсолютной величине.
n = int(input())
a = []
for i in range(n):
    a.append(list(map(int, input().split())))
for j in range(n):
    for i in range(n):
        print(a[i][j], end=' ')
    print()
# Обход элементов матрицы - 2
# Задана целочисленная квадратная матрица размером N x N.
# Необходимо обойти элементы этой матрицы снизу вверх справо налево и вывести элементы именно
# в таком порядке в виде таблицы.
# Программа принимает на вход натуральное число N – количество строк и столбцов матрицы.
# В каждой из последующих N строк записаны N целых чисел – элементы матрицы.
n = int(input())
a = []
for i in range(n):
    a.append(list(map(int, input().split())))
for j in range(n - 1, -1, -1):
    for i in range(n - 1, -1, -1):
        print(a[i][j], end=' ')
    print()
# Обход элементов матрицы - 3
# Задана целочисленная матрица, состоящая из N строк и M столбцов.
# Необходимо обойти элементы этой матрицы cправо налево сверху вниз и вывести элементы именно
# в таком порядке в виде таблицы.
# Программа принимает на вход два натуральных числа N и M – количество строк и столбцов матрицы.
# В каждой из последующих N строк записаны M целых чисел – элементы матрицы.
n, m = map(int, input().split())
a = []
for i in range(n):
    a.append(list(map(int, input().split())))
for i in range(n):
    for j in range(m - 1, -1, -1):
        print(a[i][j], end=' ')
    print()
# Обход элементов матрицы - 4
# Задана целочисленная матрица, состоящая из N строк и M столбцов.
# Необходимо обойти элементы этой матрицы слева направо снизу вверх и вывести элементы именно
# в таком порядке в виде таблицы.
# Программа принимает на вход два натуральных числа N и M – количество строк и столбцов матрицы.
# В каждой из последующих N строк записаны M целых чисел – элементы матрицы.
n, m = map(int, input().split())
a = []
for i in range(n):
    a.append(list(map(int, input().split())))
for i in range(n - 1, -1, -1):
    for j in range(m):
        print(a[i][j], end=' ')
    print()
# A. Красивая матрица
# Перед Вами матрица размера 5 × 5, состоящая из 24-x нулей и единственной единицы.
# Строки матрицы пронумеруем числами от 1 до 5 сверху вниз, столбцы матрицы пронумеруем числами от 1 до 5 слева направо.
# За один ход разрешается применить к матрице одно из двух следующих преобразований:
# Поменять местами две соседние строки матрицы,
# то есть строки с номерами i и i + 1 для некоторого целого i (1 ≤ i < 5).
# Поменять местами два соседних столбца матрицы,
# то есть столбцы с номерами j и j + 1 для некоторого целого j (1 ≤ j < 5).
# Вы считаете, что матрица будет выглядеть красиво,
# если единственная единица этой матрицы будет находиться в ее центре
# (в клетке, которая находится на пересечении третьей строки и третьего столбца).
# Посчитайте, какое минимальное количество ходов потребуется, чтобы сделать матрицу красивой.
# Входные данные
# Входные данные состоят из пяти строк, в каждой из которых записаны пять целых чисел:
# j-ое число в i-ой строке входных данных обозначает элемент матрицы, стоящий на пересечении i-ой строки и j-ого столбца
# Гарантируется, что матрица состоит из 24-x нулей и единственной единицы.
# Выходные данные
# Выведите единственное целое число — минимальное количество действий, которое требуется, чтобы сделать матрицу красивой
a = []
for i in range(5):
    a.append(list(map(int, input().split())))
for i in range(5):
    for j in range(5):
        if a[i][j] == 1:
            r = i
            c = j
print(abs(2 - r) + abs(2 - c))
# Сумма строк и столбцов двумерного массива
# Задан целочисленный двумерный массив, состоящий из N строк и M столбцов.
# Требуется вычислить сумму элементов в каждой строке и в каждом столбце.
# Программа получает на вход два натуральных числа N и M – количество строк и столбцов двумерного массива.
# В каждой из последующих N строк записаны M целых чисел – элементы массива.
# Все числа во входных данных не превышают 1000 по абсолютной величине.
# В первой строке вам необходимо вывести N чисел – суммы элементов массива для каждой строки в отдельности.
# Во второй строке в аналогичном формате выведите M чисел – суммы элементов для каждого столбца.
n, m = map(int, input().split())
a = []
for i in range(n):
    a.append(list(map(int, input().split())))
for i in range(n):
    s = 0
    for j in range(m):
        s += a[i][j]
    print(s, end=' ')
print()
for e in range(m):
    c = 0
    for r in range(n):
        c += a[r][e]
    print(c, end=' ')
# Симметричная ли матрица?
# Проверьте, является ли двумерный массив симметричным относительно главной диагонали.
# Главная диагональ — та, которая идёт из левого верхнего угла двумерного массива в правый нижний.
# Входные данные
# Программа получает на вход число n<100, являющееся числом строк и столбцов в массиве.
# Далее во входном потоке идет n строк по n чисел, являющихся элементами массива.
# Выходные данные
# Программа должна выводить слово Yes для симметричного массива и слово No для несимметричного.
n = int(input())
a = []
sim = True
for i in range(n):
    a.append(list(map(int, input().split())))
for i in range(n):
    for j in range(n):
        if a[i][j] != a[j][i]:
            sim = False
if sim:
    print("Yes")
else:
    print("No")
# Состязания
# В метании молота состязается n спортcменов. Каждый из них сделал m бросков.
# Победителем считается тот спортсмен, у которого сумма результатов по всем броскам максимальна.
# Если перенумеровать спортсменов числами от 0 до n-1, а попытки каждого из них – от 0 до m-1,
# то на вход программа получает массив A[n][m], состоящий из неотрицательных целых чисел.
# Программа должна определить максимальную сумму чисел в одной строке и вывести на экран эту сумму и номер строки,
# для которой достигается эта сумма.
# Входные данные
# Программа получает на вход два числа n и m, являющиеся числом строк и столбцов в массиве.
# Далее во входном потоке идет n строк по m чисел, являющихся элементами массива.
# Выходные данные
# Программа должна вывести  2 числа: сумму и номер строки, для которой эта сумма достигается. Если таких строк несколько
# то выводится номер наименьшей из них. Не забудьте, что нумерация строк (спортсменов) начинается с 0.
n, m = map(int, input().split())
a = []
b = []
for i in range(n):
    a.append(list(map(int, input().split())))
for i in range(n):
    s = 0
    for j in range(m):
        s += a[i][j]
    b.append(s)
print(max(b))
print(b.index(max(b)))
# Состязания - 2
# В метании молота состязается n спортcменов. Каждый из них сделал m бросков.
# Победителем соревнований объявляется тот спортсмен, у которого максимален наилучший результат по всем броскам.
# Таким образом, программа должна найти значение максимального элемента в данном массиве,
# а также его индексы (то есть номер спортсмена и номер попытки).
# Входные данные
# Программа получает на вход два числа n и m, являющиеся числом строк и столбцов в массиве.
# Далее во входном потоке идет n строк по m чисел, являющихся элементами массива.
# Выходные данные
# Программа выводит значение максимального элемента, затем номер строки и номер столбца, в котором он встречается.
# Если в массиве несколько максимальных элементов, то нужно вывести минимальный номер строки,
# в которой встречается такой элемент, а если в этой строке таких элементов несколько,
# то нужно вывести минимальный номер столбца.
# Не забудьте, что все строки и столбцы нумеруются с 0.
n, m = map(int, input().split())
a = []
stroki = n
stolb = m
maxi = 0
for i in range(n):
    a.append(list(map(int, input().split())))
for i in range(n):
    for j in range(m):
        if a[i][j] > maxi:
            maxi = a[i][j]
            stroki = i
            stolb = j
print(maxi)
print(stroki, stolb)
# Состязания - 3
# В метании молота состязается n спортcменов. Каждый из них сделал m бросков.
# Побеждает спортсмен, у которого максимален наилучший бросок. Если таких несколько,
# то из них побеждает тот, у которого наилучшая сумма результатов по всем попыткам.
# Если и таких несколько, победителем считается спортсмен с минимальным номером.Определите номер победителя соревнований
# Входные данные
# Программа получает на вход два числа n и m, являющиеся числом строк и столбцов в массиве.
# Далее во входном потоке идет n строк по m чисел, являющихся элементами массива.
# Выходные данные
# Программа должна вывести одно число - номер победителя соревнований.
# Не забудьте, что  строки(спортсмены) нумеруются с 0
a = []
n, m = map(int, input().split())
for i in range(n):
    a.append(list(map(int, input().split())))

maxi_schet = 0
summ_str = 0
max_index = 0

for i in range(n):
    max_br = 0
    max_str = 0
    for j in range(m):
        max_str += a[i][j]
        if a[i][j] > max_br:
            max_br = a[i][j]

    if max_br > maxi_schet:
        maxi_schet = max_br
        summ_str = max_str
        max_index = i
    elif maxi_schet == max_br and max_str > summ_str:
        maxi_schet = max_br
        summ_str = max_str
        max_index = i
print(max_index)
# Состязания - 4
# В метании молота состязается n спортcменов.
# Каждый из них сделал m бросков.
# Победитель определяется по лучшему результату.
# Определите количество участников состязаний, которые разделили первое место,
# то есть определите количество строк в массиве, которые содержат значение, равное наибольшему.
# Входные данные
# Программа получает на вход два числа n и m, являющиеся числом строк и столбцов в массиве.
# Далее во входном потоке идет n строк по m чисел, являющихся элементами массива.
# Выходные данные
# Программа должна вывести  одно число - количество победителей соревнования.
a = []
n, m = map(int, input().split())
for i in range(n):
    a.append(list(map(int, input().split())))

count = 0
max_br = 0
for i in range(n):
    for j in range(m):
        if a[i][j] > max_br:
            max_br = a[i][j]
for i in a:
    if max_br in i:
        count += 1
print(count)
# Симпатичный узор
# На днях Иван у себя в прихожей выложил кафель, состоящий из квадратных черных и белых плиток.
# Прихожая Ивана имеет квадратную форму 4х4, вмещающую 16 плиток. Теперь Иван переживает, что узор из плиток,
# который у него получился, может быть не симпатичным. С точки зрения дизайна симпатичным узором считается тот,
# который не содержит в себе квадрата 2х2, состоящего из плиток одного цвета.
# Примеры возможных узоров:
# Симпатичный узор
# По заданному расположению плиток в прихожей Ивана требуется определить: является ли выполненный узор симпатичным.
# Программе поступает на вход 4 строки по 4 символа «W» или «B» в каждой, описывающие узор из плиток.
# Символ «W» обозначает плитку белого цвета, а «B» - черного.
# Ваша задача вывести «Yes», если узор является симпатичным и «No» в противном случае
a = []
sim = True
for i in range(4):
    a.append(list(input()))
for i in range(3):
    for j in range(3):
        if a[i][j] == a[i + 1][j] == a[i][j + 1] == a[i + 1][j + 1]:
            sim = False
if sim:
    print("Yes")
else:
    print("No")
# Миша и негатив
# Миша уже научился хорошо фотографировать и недавно увлекся программированием. Первая программа, которую он написал,
# позволяет формировать негатив бинарного черно-белого изображения.
# Бинарное черно-белое изображение – это прямоугольник, состоящий из пикселей, каждый из которых может быть либо черным,
# либо белым. Негатив такого изображения получается путем замены каждого черного пикселя на белый,
# а каждого белого пикселя – на черный.
# Миша, как начинающий программист, написал свою программу с ошибкой,
# поэтому в результате ее исполнения мог получаться некорректный негатив.
# Для того чтобы оценить уровень несоответствия получаемого негатива исходному изображению,
# Миша начал тестировать свою программу.
# В качестве входных данных он использовал исходные изображения.
# Сформированные программой негативы он начал тщательно анализировать,
# каждый раз определяя число пикселей негатива, которые получены с ошибкой.
# Требуется написать программу, которая в качестве входных данных использует исходное бинарное черно-белое изображение и
# полученный Мишиной программой негатив, и на основе этого определяет количество пикселей, в которых допущена ошибка.
# Программа сперва считывает числа n и m (1 ≤ n, m ≤ 100) – высоту и ширину исходного изображения (в пикселях).
# Последующие n строк содержат описание исходного изображения. Каждая строка состоит из m символов «B» и «W».
# Символ «B» соответствует черному пикселю, а символ «W» – белому. Далее следует пустая строка,
# а после нее – описание выведенного Мишиной программой изображения в том же формате, что и исходное изображение.
# Необходимо вывести на экран число пикселей негатива, которые неправильно сформированы Мишиной программой.
n, m = map(int, input().split())
a = []
b = []
count = 0
for i in range(n):
    a.append(input())
input()
for i in range(n):
    b.append(input())
for i in range(n):
    for j in range(m):
        if a[i][j] == b[i][j]:
            count += 1
print(count)
# A. Таблица умножения
# Рассмотрим таблицу из n строк и n столбцов.
# Известно, что в клетке, образованной пересечением i-й строки и j-го столбца
# записано число i × j. Строки и столбцы нумеруются с единицы.
# Дано целое положительное число x. Требуется посчитать количество клеток таблицы, в которых находится число x.
# Входные данные
# В единственной строке находятся числа n и x (1 ≤ n ≤ 105, 1 ≤ x ≤ 109) — размер таблицы и число,
# которое мы ищем в таблице.
# Выходные данные
# Выведите единственное число: количество раз, которое число x встречается в таблице.
n, x = map(int, input().split())
count = 0
for i in range(1, n + 1):
    for j in range(1, n + 1):
        if i * j == x:
            count += 1
print(count)
# A. Матчи
# Манао работает на спортивном телевидении.
# Он долгое время наблюдал за футбольными матчами чемпионата одной страны и начал замечать разные закономерности.
# Например, у каждой команды есть две формы: домашняя и выездная. Когда команда проводит матч на своем стадионе,
# футболисты надевают домашнюю форму, а когда на чужом — выездную.
# Единственное исключение из этого правила—когда цвет домашней формы принимающей команды совпадает с цветом формы госте.
# В таком случае домашняя команда облачается в свою выездную форму.
# Цвета домашней и выездной формы для каждой команды различны.
# В чемпионате страны участвует n команд и он состоит из n·(n - 1) матчей:
# каждая из команд принимает каждую другую команду на своем стадионе.
# Манао задумался, а сколько раз в течение одного чемпионата случится, что команда, играющая на своем стадионе,
# оденет выездную форму? Обратите внимание, что для подсчета этого количества порядок матчей не играет никакого значения
# Вам даны цвета домашней и выездной формы каждой команды.
# Для удобства эти цвета пронумерованы целыми числами таким образом,
# что никакие два разных цвета не имеют одинаковый номер.
# Помогите Манао найти ответ на его вопрос.
# Входные данные
# В первой строке содержится целое число n (2 ≤ n ≤ 30).
# В каждой из следующих n строк записана пара разделенных одним пробелом различных целых чисел
# hi, ai (1 ≤ hi, ai ≤ 100) — номер цвета домашней и выездной форм i-ой команды соответственно.
# Выходные данные
# В единственной строке выведите количество матчей, в которых домашняя команда выступит в выездной форме.
n = int(input())
a = []
count = 0
for i in range(n):
    a.append(list(map(int, input().split())))
for i in range(n - 1):
    for j in range(i + 1, n):
        if a[i][0] == a[j][1]:
            count += 1
        if a[i][1] == a[j][0]:
            count += 1
print(count)
# Морской бой - 2
# Морской бой-игра для двух участников,в которой игроки по очереди называют координаты на неизвестной им карте соперника
# Если у соперника по этим координатам имеется корабль, то корабль или его часть «топится»,
# а попавший получает право сделать еще один ход. Цель игрока - первым поразить все корабли противника.
# «Морской бой» очень популярен среди учеников одной физико-математической школы.
# Ребята очень любят в него играть на переменах. Вот и сейчас ученики Иннокентий и Емельян начали новую партию.
# Правила, по которым ребята расставляют корабли перед началом партии, несколько отличаются от классических.
# Во-первых, игра происходит на поле размером N×M, а не 10×10. Во-вторых, число кораблей,
# их размер и форма выбираются ребятами перед партией - так играть намного интереснее.
# Емельян уже расставил все свои корабли, кроме одного однопалубного.
# Такой корабль занимает ровно одну клетку.
# Задана расстановка кораблей Емельяна.
# Найдите число способов поставить оставшийся однопалубный корабль.
# При этом учитывайте, что по правилам его можно ставить только в ту клетку, все соседние с которой не заняты.
# В этой задаче соседними считаются клетки, имеющие общую сторону.
# Программа считывает два числа: N и M (1 ≤ N, M ≤ 100).
# Последующие N строк описывают игровое поле - каждая из них содержит M символов.
# Символом «.» (точка) обозначена свободная клетка, символом «*» (звездочка) - занятая кораблем.
# Необходимо вывести на экран ответ на задачу
n, m = map(int, input().split())
mas = []
mas.append("." * (m + 2))
for i in range(n):
    row = '.' + input() + '.'
    mas.append(row)
mas.append("." * (m + 2))
kol = 0
for i in range(1, n + 1):
    for j in range(1, m + 1):
        if mas[i - 1][j] == '.' and mas[i][j + 1] == '.' and mas[i + 1][j] == '.' and mas[i][j - 1] == '.' and mas[i][
            j] == '.':
            kol += 1
print(kol)
# Даны числа n и m. Создайте массив A[n][m] и заполните его змейкой (см. пример).
# Входные данные
# Программа получает на вход два числа n и m.
# Выходные данные
# Программа должна вывести  полученный массив, при этом между числами может быть любое количество пробелов.
n, m = map(int, input().split())
k = 0
for i in range(n):
    k += m
    row = range(i * m, k)
    if i % 2 != 0:
        row = reversed(row)
    for x in row:
        print(str(x).ljust(3), end='')
    print()
# ещё один вариант решения
# по строкам
n = int(input())
tab = [[0] * n for i in range(n)]

index = 0
for i in range(n):
    if i % 2 == 0:
        for j in range(0, n, +1):
            index += 1
            tab[i][j] = index
    else:
        for j in range(n - 1, -1, -1):
            index += 1
            tab[i][j] = index


for i in tab:
    print(*i)

# по столбцам
n = int(input())
tab = [[0] * n for i in range(n)]

index = 0
for j in range(n):
    if j % 2 == 0:
        for i in range(0, n, +1):
            index += 1
            tab[i][j] = index
    else:
        for i in range(n - 1, -1, -1):
            index += 1
            tab[i][j] = index


for i in tab:
    print(*i)

# A. Фотографии Брейна
# Маленького, но очень смелого мышонка Брейна не взяли в летнюю школу юных злодеев.
# Он расстроился и решил отодвинуть свои планы по захвату мира, а вместо этого податься в фотографы.
# Как вам наверняка известно, самые крутые фотографии получаются на пленку (ведь тогда в хештегах можно указать #пленка)
# Брейн наснимал очень много красочных фотографий на цветную и черно-белую пленки.
# Затем проявил и перевел их в цифровой вид. Но вот незадача!
# Теперь цветные и черно-белые фотографии лежат в одной папке, и, чтобы их рассортировать, нужно потратить не один час!
# Так как Брейн теперь фотограф, а не программист, он просит вас помочь ему для одной фотографии определить,
# цветная она или черно-белая.
# Фотография представляет собой матрицу размера n × m, в каждой ячейке которой хранится символ,
# обозначающий цвет соответствующего пикселя. Всего существует 6 цветов:
# 'C' (cyan) — голубой
# 'M' (magenta) — пурпурный
# 'Y' (yellow) — желтый
# 'W' (white) — белый
# 'G' (grey) — серый
# 'B' (black) — черный
# Фотографию можно считать черно-белой, если в ней есть только белый, серый или черный цвет.
# Если же присутствует хоть один пиксель голубого, пурпурного или желтого цвета, она цветная.
# Входные данные
# В первой строке содержится два целых числа n и m (1 ≤ n, m ≤ 100)
# — количество строк и столбцов в матрице пикселей фотографии соответственно.
# Далее следуют n строк, описывающих строки матрицы.
# Каждая из них состоит из m разделенных пробелом символов, описывающих цвета пикселей в строке.
# Каждый из символов в строке является одним из символов 'C', 'M', 'Y', 'W', 'G' или 'B'.
# Выходные данные
# В единственной строчке выведите «#Black&White» (без кавычек),
# если фотография черно-белая, и «#Color» (без кавычек), если цветная.
n, m = map(int, input().split())
a = []
for i in range(n):
    a.append(input().split())
count = 0
for i in range(n):
    for j in range(m):
        if a[i][j] == "C" or a[i][j] == "M" or a[i][j] == "Y":
            count += 1
if count == 0:
    print("#Black&White")
else:
    print("#Color")
# Спираль
# Требуется вывести квадрат, состоящий из N×N клеток, заполненных числами от 1 до N2 по спирали (см. примеры).
# Входные данные
# Программа получает на вход одно число n.
# Выходные данные
# Программа должна вывести матрицу, заполненную числами от 1 до N2 по спирали,
# при этом между числами может быть любое количество пробелов.
# Не допускается начинать спираль в ином, кроме верхнего левого, углу,
# закручивать спираль против часовой стрелки или изнутри наружу.
# НЕ РЕШЁННАЯ, ОБЯЗАТЕЛЬНА ДЛЯ ДОРАБОТКИ!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
n = int(input())
tab = [[0] * n for i in range(n)]
tab[0] = [(j + 1) for j in range(n)]
index, y, x, r = n, 0, n - 1, n
tab[n // 2][n // 2] = n * n
while index <= n * n:
    r -= 1
    for i in range(r):  # вертикаль
        y += 1
        index += 1
        tab[y][x] = index
    for i in range(r):  # горизонталь
        x -= 1
        index += 1
        tab[y][x] = index
    r -= 1
    for i in range(r):  # вертикаль
        y -= 1
        index += 1
        tab[y][x] = index
    for i in range(r):  # горизонталь
        x += 1
        index += 1
        tab[y][x] = index
    r -= 1
    # if index >= n * n --> brake нужна проверка для чётных матриц
    [print(*i) for i in tab]

# A. Тортминатор
# Дан прямоугольный торт, который имеет вид таблицы размером r × c.
# Каждая ячейка таблицы содержит либо гадкую клубничку, либо является пустой.
# Например, торт размера 3 × 4 может выглядеть так:
# Тортминатор намерен съесть этот торт! Каждый раз, когда он ест,
# он выбирает строку или столбец, не содержащие гадкой клубнички,
# а содержащие по крайней мере одну несъеденную ячейку торта. Затем Тортминатор поедает все выбранные им ячейки торта.
# Тортминатор может есть сколько угодно раз.
# Пожалуйста, выведите максимальное количество ячеек, которые может съесть Тортминатор.
# Входные данные
# Первая строка содержит два целых числа r и c (2 ≤ r, c ≤ 10),
# обозначающих количество строк и количество столбцов в торте.
# Следующие r строк содержат по c символов — j-ый символ i-ой строки обозначает содержимое ячейки в строке i и столбце j
# и имеет одно из следующих значений:
# символ '.' обозначает ячейку торта без гадкой клубнички;
# символ 'S' обозначает ячейку торта с гадкой клубничкой.
# Выходные данные
# Выведите максимальное количество ячеек торта, которые может съесть тортминатор.
n, m = map(int, input().split())

tort = []
for i in range(n):
    tort.append(list(input()))
s1 = []
counts = 0
for i in range(n):
    if 'S' not in tort[i]:
        for j in range(m):
            if tort[i][j] == '.':
                counts += 1
                tort[i][j] = '!'
for j in range(m):
    s1 = []
    for i in range(n):
        s1.append(tort[i][j])
    if 'S' not in s1:
        counts += s1.count('.')
print(counts)