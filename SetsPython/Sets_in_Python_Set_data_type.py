# Множества в Python. Тип данных set
#  Множество - неупорядочнная коллекция уникальных элементов(отсутствуют повторяющиеся значения)
# множество могужет состоять только с неизменяемых объектов
# создание
a = {1, 2, 3, 1, 2, 3, 1, 2, 3, 4}
print(a)
b = {'hi', 'ho', 'hi,', 'ho', 'xex'}
print(b)
c = {'dsadsddadadda'}
print(c)
d = set([1, 2, 3, 4, 3, 2, 1])
e = set(range(5))
r = set()  # пустое множество
# пример
g = [1, 2, 3, 1, 2, 3, 1, 2, 3, 4]
g = list(set(g))
print(a)

# добавление элемента
# что бы добавть элемент в множество нужно использовать метод add
k = {54, 52, 54, 65, 54, 65}
k.add(34)
print(k)
k.update([5, 6, 7])
k.update('hello')
k.update(range(5, 10))
k.update({4, 5, 6, 4, 6})
print(k)

# удаление элементов
w = {54, 52, 54, 65, 54,31, 65}
w.discard(31)
w.discard(31)  # при повторном вызове вернёт тот же результат
# w.remove(31)  # при повторном вызове вернёт ошибку
w.pop()  # удалятсья будет случайный элемент
w.clear()  # очищает все элементы множества

# операции над множествами
print(len(w))
print(31 in w, 7 not in a)
#  нахожденя пересечения при помощи амперсанта
s = {4, 3, 2, 1}
v = {3, 4, 5, 6, 7}
print(s & v)
# метод по замене значениями
print(s.intersection(v))  # сами списки не изменились
print(s, v)
print(s.intersection_update(v))  # списки изменяться

# объеденение списков
print(s | v)
print(s.union(v))
s = s.union(v)
# вычитание множеств
print(s - v)
# семитричная разность
print(s ^ v)
# сравнивание
print(s == v)

# обход элементов множеств и только по значениям
for i in s:
    print(i)

# пример
text = input()
y = set()
while text != "":
    slova = text.split()
    a.update(slova)
    text = input()
print(len(y))

# Задачки
# Даны два списка чисел.
# Выведите все числа, которые входят как в первый, так и во второй список в порядке возрастания.
a = set(map(int, input().split()))
b = set(map(int, input().split()))
print(*sorted(a & b))

# Даны два списка чисел.
# Выведите все числа в порядке возрастания, которые входят в первый список, но при этом отсутствуют во втором.
a = set(map(int, input().split()))
b = set(map(int, input().split()))
c = (a ^ b)
t = []
for i in c:
    if i in a:
        t.append(i)
    else:
        continue
print(*sorted(t))

a,b = set(input().split()), set(input().split())
print(*sorted(a - b))

# Напишите программу, которая выводит все цифры, встречающиеся в символьной строке больше одного раза.
# Входные данные
# Входная строка может содержать содержит цифры, пробелы и латинские буквы.
# Выходные данные
# Программа должна вывести в одну строчку в порядке возрастания все цифры,
# встречающиеся во входной строке больше одного раза. Если таких цифр нет, нужно вывести слово 'NO'.
a = input()
s = set()
for i in a:
    if i.isdigit():
        if a.count(i) > 1:
            s.add(i)
if len(s) == 0:
    print('NO')
else:
    print(*sorted(s))

# Напишите программу, которая удаляет из строки все повторяющиеся символы, при этом регистр букв необходимо учитывать.
# Входные данные
# Программа получает на вход строку, состоящую из заглавных и строчных символов, цифр и знаков препинания.
# Выходные данные
# Программа должна вывести исходную строку, из которой удалены все повторяющиеся символы.
a = input()
print(''.join(sorted(set(a), key=a.index)))

# Дили Вили Били завели себе аккаунты в одной известной соцсети.
# И затем они решили узнать у кого из них самое большое количество уникальных комментатор.
# Ваша задача помочь им в этом и собрать нужную информацию.
# Входные данные
# В каждой строке будет вводиться одно из имен наших героев,
# а затем через двоеточие и пробел имя комментатора.
# Комментаторы могут повторяться и комментировать разных персонажей
# Строка "конец" означает окончание ввода и встречается последней
# Входные данные
# Ваша задача вывести в порядке уменьшения популярности 3 строки вида:
# "Количество уникальных комментаторов у <имя героя> - <количество комментаторов>"
# На склонение давайте не будем обращать обращать внимания в этой задаче.
# Гарантируется, что количество уникальных комментаторов у всех наших героев разное.
# Могут быть ситуации, когда у героя нету ни единого комментатора,
# в таком случае все равно нужно выводить информацию о нем.

# Девушка или Юноша
# В наши дни очень много парней ставят себе фотографии красивых девушек на аватарки на форумах.
# Из-за этого очень часто сложно определить пол пользователя на форуме.
# В прошлом году наш герой пообщался в чате на форуме с одной красоткой (как он думал).
# После этого наш герой и предполагаемая красотка стали общаться еще чаще и в конце концов стали парой в сети.
# Но вчера наш герой захотел увидеть свою красотку в реальной жизни и, каково же было его удивление,
# когда красоткой оказался здоровенный мужчина! Наш герой очень расстроился и теперь он, наверное,
# никогда больше не сможет полюбить. Сейчас к нему пришла в голову идея, как по имени пользователя определить его пол.
#
# Вот его метод: если количество различных символов в имени пользователя нечетное, тогда пользователь мужского пола,
# иначе — женского. Вам дана строка, обозначающая имя пользователя,
# помогите нашему герою определить по ней пол пользователя по описанному методу.
# Входные данные
# В первой строке записана непустая строка, состоящая только из строчных букв латинского алфавита — имя пользователя.
# Эта строка состоит из не более чем 100 букв.
# Выходные данные
# Если пользователь оказался женского пола по методу нашего героя, выведите «CHAT WITH HER!» (без кавычек),
# иначе, выведите «IGNORE HIM!» (без кавычек).
name = input()
s = set()
for i in name:
    if i not in s:
        s.add(i)
if len(s) % 2 == 0:
    print('CHAT WITH HER!')
else:
    print('IGNORE HIM!')

#  Не смешите мои подковы
# Конь Валера собрался с друзьями на вечеринку.
# Он давно следит за тенденциями моды и поэтому знает, что сейчас очень популярно носить все подковы разного цвета.
# С прошлого года у Валеры остались четыре подковы, но, возможно, некоторые из них имеют одинаковый цвет.
# В этом случае, чтобы не ударить в грязь лицом перед своими стильными товарищами,
# ему нужно сходить в магазин и купить дополнительно несколько каких-нибудь подков.
# К счастью в магазине продаются подковы всех возможных цветов, и у Валеры имеется достаточно денег,
# чтобы купить любые четыре. Однако в целях экономии он хотел бы потратить как можно меньше денег,
# поэтому вам нужно помочь Валере и определить, какое минимальное количество подков нужно купить,
# чтобы он смог надеть на вечеринку четыре подковы различного цвета.
# Входные данные
# В первой строке через пробел записаны четыре целых числа s1, s2, s3, s4 (1 ≤ s1, s2, s3, s4 ≤ 109)
# — цвета подков, имеющихся у Валеры.
# Считайте, что все возможные цвета пронумерованы целыми числами.
# Выходные данные
# Выведите единственное целое число — минимальное количество подков, которое нужно купить.
print(4 - len(set(input().split())))

# Красивый год
# Кажется, еще совсем недавно наступил новый 2013 год.
# А знали ли Вы забавный факт о том, что 2013 год является первым годом после далекого 1987 года,
# в котором все цифры различны?
# Теперь же Вам предлагается решить следующую задачу: задан номер года, найдите наименьший номер года,
# который строго больше заданного и в котором все цифры различны.
# Входные данные
# В единственной строке задано целое число y (1000 ≤ y ≤ 9000) — номер года.
# Выходные данные
# Выведите единственное целое число — минимальный номер года, который строго больше y, в котором все цифры различны.
# Гарантируется, что ответ существует.
years = int(input())

for i in range(years + 1, 9999):
    s = set(list(str(i)))
    if len(s) == 4:
        print(i)
        break

# Антон и буквы
# Недавно у Антона появилось множество, состоящие из маленьких латинских букв.
# Он аккуратно выписал все буквы, которые в него входят в одну строку через запятую.
# Для красоты он так же добавил в начало этой строки открывающуюся фигурную скобку, а в конец — закрывающуюся.
# К сожалению, Антон иногда забывал, что уже записал некоторую букву, и выписывал ее снова.
# Он просит вас посчитать общее число различных букв в его множестве.
# Входные данные
# В первой и единственной строке задано описание множества букв. Длина строки не превышает 1000.
# Гарантируется, что строка начинается с открывающейся фигурной скобки, а заканчивается закрывающейся.
# Между ними через запятую перечислены маленькие латинские буквы. После каждой запятой следует пробел.
text = input()[1:-1]
if len(text) == 0:
    print(0)
else:
    print(len(set(text.split(', ',))))

# Панграмма
# Слово или предложение на некотором языке называется панграммой,
# если в нем встречаются все символы алфавита этого языка хотя бы один раз. Панграммы часто используют в типографии для
# демонстрации шрифтов или тестирования средств вывода различных устройств.
# Вам дана строка, состоящая из маленьких и больших латинских букв.
# Проверьте, является ли эта строка панграммой.
# Считается, что строка содержит букву латинского алфавита, если эта буква встречается в верхнем или нижнем регистре.
# Входные данные
# В первой строке записано одно целое число n (1 ≤ n ≤ 100) — количество символов в строке.
# Во второй строке записана сама строка. Строка содержит исключительно строчные и заглавные латинские буквы.
# Выходные данные
# Выведите «YES», если строка является панграммой, и «NO» в противном случае.
from string import ascii_lowercase
new_s = set(ascii_lowercase)
n = int(input())
text = input().lower()
s = set()
for i in text:
    if i not in s:
        s.add(i)

res = s & new_s
if len(res) == 26:
    print('YES')
else:
    print('NO')

# Дили Вили Били завели себе аккаунты в одной известной соцсети.
# И затем они решили узнать у кого из них самое большое количество уникальных комментатор.
# Ваша задача помочь им в этом и собрать нужную информацию.
# Входные данные
# В каждой строке будет вводиться одно из имен наших героев, а затем через двоеточие и пробел имя комментатора.
# Комментаторы могут повторяться и комментировать разных персонажей
# Строка "конец" означает окончание ввода и встречается последней
# Входные данные
# Ваша задача вывести в порядке уменьшения популярности 3 строки вида:
# "Количество уникальных комментаторов у <имя героя> - <количество комментаторов>"
# На склонение давайте не будем обращать обращать внимания в этой задаче.
# Гарантируется, что количество уникальных комментаторов у всех наших героев разное.
# Могут быть ситуации, когда у героя нету ни единого комментатора,
# в таком случае все равно нужно выводить информацию о нем.

d = {}
while True:
    data = input()
    if data == "конец":
        break
    name, comment = data.split(':')
    d.setdefault(name, set()).add(comment)
for name in d:
    print(f'Количество уникальных комментаторов у {name} - {len(d[name])}')

