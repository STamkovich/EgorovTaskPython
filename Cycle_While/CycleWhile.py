# Цыкл While
i = 1
while i < 6:
    print(i)
    i = i + 1

a = int(input())
while a != 0:
    print("Повтрите ввод")
    a = int(input())

guess = input()
password = "qwerty"
count = 0
while guess != password:
    count += 1
    print("НЕправильный пороль")
    guess = input()
print("Вы потратии ", count, "Попыток")

a = [1, 2, 3] * 5
print(a)
while 3 in a:
    a.remove(3)
print(a)

s = "privet"
while len(s) > 0:
    print(s[0], s[1:])
    s = s[1:]

s = "privetewfwe1233"
while len(s) > 0:
    bukva = s[0]
    if "a" <= bukva <= "z":
        print(bukva, "small")
    elif "A" <= bukva <= "Z":
        print(bukva, "big")
    elif bukva.isdigit():
        print(bukva, "digit")
    else:
        print(bukva, "znak")
    s = s[1:]
# задачки
# Пользователь вводит числа, и пока введённые числа не равны нулю, программа работает,
# как только происходит иное –завершает работу.
a = int(input())
while a != 0:
    print("Повтрите ввод")
    a = int(input())

# Мишка Лимак хочет стать самым большим медведем, ну, или хотя бы стать больше своего старшего брата Боба.
# Сейчас вес Лимака равен a, а вес Боба равен b. Гарантируется, что вес Лимака меньше или равен весу Боба.
# Лимак ест много, и его вес утраивается каждый год, а вес Боба удваивается каждый год.
# Через сколько целых лет Лимак станет строго больше (т. е. будет весить строго больше) Боба?
# В единственной строке находятся два целых числа a и b  — веса Лимака и Боба соответственно.
# Выведите одно целое число — через сколько целых лет Лимак станет строго больше Боба.
a, b = map(int, input().split())
count = 0
while a <= b:
    count += 1
    a = a * 3
    b = b * 2
print(count)

# На вход программе поступает слово. Вам необходимо воспроизвести процесс,
# в котором каждый раз у этого слово будет пропадать первая и последняя буква.
# Этот процесс необходимо закончить, когда слове останется только одна буква или слово  станет пустой строкой.
# При этом результат каждого этапа нужно выводить
a = input().strip()
while len(a) > 0:
    print(a)
    a = a[1:-1]

# Выведите все точные квадраты натуральных чисел, не превосходящие данного числа N.
# Задано единственное целое число N
# Необходимо вывести  все точные квадраты натуральных чисел, не превосходящие данного числа N.
a = int(input())
b = 0
c = 0
while b <= a:
    b += 1
    c = b ** 2
    if not c <= a:
        break
    print(c)

# В первый день спортсмен пробежал X километров.
# В каждый последующий день он увеличивал пробег на 15% от предыдущего дня. Вам необходимо определить номер дня,
# в который пробег спортсмена составил не менее Y километров. Само число Y будем поступать на вход программе.
x, y = map(float, input().split())
z = 1
while x <= y:
    x = x * 1.15
    z += 1
print(z)

# Вася и носки
# У Васи есть n пар носков. Утром каждого дня, собираясь в школу, Вася должен надеть пару носков.
# Вечером, прийдя со школы, Вася снимает надетые носки и выбрасывает их.
# Каждый m-й день (в дни с номерами m, мама покупает Васе одну пару носков.
# Она делает это поздно вечером, поэтому Вася может надеть новые носки не раньше следующего дня.
# На сколько подряд идущих дней Васе хватит носков?
# В единственной строке записано два целых числа n и m, разделенные пробелом.
# Выведите единственное целое число — ответ на задачу.
n, m = map(int, input().split())
m1 = 0
while n > 0:
    n -= 1
    m1 += 1
    if m1 % m == 0:
        n += 1
print(m1)

# Возьмём число. Умножим его на его же первую цифру. Результат умножим на первую цифру результата.
# И так далее. Например, начнём с 8:
# 8 \to 8*8=64 \\ 64 \to 6*64=384 \\ 384 \to 3*384 =1152 \\ 1152 \to 1*1152 =11528→8∗8=64
# 64→6∗64=384
# 384→3∗384=1152
# 1152→1∗1152=1152
# Очевидно, когда первая цифра очередного числа в такой последовательности становится равной 1,
# числа перестают изменяться. Но это происходит не при всех начальных числах.
# Напишем программу, которая будет хотя бы приблизительно определять судьбу введённого числа n.
# Начиная с числа n, умножайте имеющееся число на его первую цифру,
# пока у получившегося числа первая цифра не станет равной 1, либо пока оно не превысит миллиарда.
# В качестве ответа выведите результат
a = int(input())
while str(a)[0] != '1' and a <=1000000000:
    a = int(str(a)[0]) * a
    if str(a)[0] == '1':
        break
print(int(a))

# В архитектуре компьютера важную роль играют числа, являющиеся степенями двойки: 1, 2, 4, 8 и так далее.
# Напишите программу, которая проверяет, является ли введённое натуральное число степенью двойки.
# Если да, то выводится сама эта степень; если нет, выводится «НЕТ»
n = int(input())
b = 1
a = 0
while b < n:
    b = b * 2
    a += 1
if b == n:
    print(a)
else:
    print('НЕТ')

# По случаю 100500-летия Берляндского государственного университета совсем скоро состоится бал!
# Уже n юношей и m девушек во всю репетируют вальс, менуэт, полонез и кадриль.
# Известно, что на бал будут приглашены несколько пар юноша-девушка, причем уровень умений танцевать партнеров
# в каждой паре должен отличаться не более чем на единицу.
# Для каждого юноши известен уровень его умения танцевать. Аналогично, для каждой девушки известен уровень
# ее умения танцевать. Напишите программу, которая определит наибольшее количество пар, которое можно образовать
# из n юношей и m девушек.
# Входные данные
# В первой строке записано целое число n (1 ≤ n ≤ 100) — количество юношей.
# Вторая строка содержит последовательность a1, a2, ..., an (1 ≤ ai ≤ 100),
# где ai — умение танцевать i-го юноши.
# Аналогично, третья строка содержит целое m (1 ≤ m ≤ 100) – количество девушек.
# В четвертой строке содержится последовательность b1, b2, ..., bm (1 ≤ bj ≤ 100),
# где bj — умение танцевать j-й девушки.
# Выходные данные
# Выведите единственное число — искомое максимальное возможное количество пар.
boys = int(input())
skill_boys = list(map(int, input().split()))
girls = int(input())
skill_girls = list(map(int, input().split()))
skill_boys.sort()
skill_girls.sort()
kol_par = 0
while skill_boys and skill_girls:
    if skill_boys[0] == skill_girls[0] or skill_boys[0] == skill_girls[0] + 1 or skill_boys[0] == skill_girls[0] - 1:
        kol_par = kol_par + 1
        skill_boys.pop(0)
        skill_girls.pop(0)
    elif skill_boys[0] != skill_girls[0] or skill_boys[0] != skill_girls[0] + 1 or skill_boys[0] != skill_girls[0] - 1:
        skill_boys.pop(0)
        skill_girls.pop(0)
print(kol_par)

# Ваня и кубики
# Ване на день рождения подарили n кубиков. Он с друзьями решил построить из них пирамиду.
# Ваня хочет построить пирамиду следующим образом: на верхушке пирамиды должен находиться 1 кубик,
# на втором уровне — 1 + 2 = 3 кубика, на третьем — 1 + 2 + 3 = 6 кубиков, и так далее.
# Таким образом, на i-м уровне пирамиды должно располагаться  кубиков.
# Ваня хочет узнать, пирамиду какой максимальной высоты он может создать с использованием имеющихся кубиков.
# Входные данные
# В первой строке записано целое число n (1 ≤ n ≤ 104) — количество кубиков, подаренных Ване.
# Выходные данные
# Выведите единственной строкой максимально возможную высоту пирамиды.
n = int(input())  # количество подаренных кубиков
count = 0  # количество кубиков, потраченных на пирамиду
height = 0  # высота пирамиды
cycles = 0  # количество итераций цикла (необходимо для для подсчета кубиков на текущей высоте пирамиды)
while n >= 0:
    cycles += 1
    count = count + cycles
    n = n - count
    if n >= 0:
        height += 1
print(height)
# Фурик очень любит уроки математики, поэтому, в отличие от Рубика, он их не посещает.
# Но теперь Фурик хочет получить хорошую оценку по математике.
# Для этого Лариса Ивановна, учительница математики, дала ему новое задание.
# Фурик сразу же решил эту задачу, а вы сможете?
# Задана система уравнений:
# Нужно посчитать количество пар целых чисел (a, b) (0 ≤ a, b), которые удовлетворяют системе.
# Входные данные
# В единственной строке заданы два целых числа n, m (1 ≤ n, m ≤ 1000) — параметры системы.
# Числа в строке разделены пробелом.
# Выходные данные
# В единственную строку выведите ответ на задачу.

# Новогодние свечки
# Программист Василий любит романтику — поэтому на этот Новый Год он решил освещать свою комнату свечами.
# У Василия есть a свечей. Когда Василий зажигает новую свечу, сначала она горит ровно один час, а затем тухнет.
# Василий — сообразительный малый, поэтому из b потухших свечей он умеет получать одну новую свечу.
# В последствии эту новую свечу (так же как и другие новые свечи) можно зажечь.
# Теперь Василию интересно, на сколько часов освещения хватит его свечек, если он будет действовать оптимальным образом
# Помогите ему найти это число.
# Входные данные
# В единственной строке заданы два целых числа a и b (1 ≤ a ≤ 1000; 2 ≤ b ≤ 1000).
# Выходные данные
# Выведите единственное целое число — количество часов, которое Василий сможет освещать комнату.
a, b = map(int, input().split())
clock = 0
while a > 0:
    a -= 1
    clock += 1
    if clock % b == 0:
        a += 1
print(clock)

# Новый год и спешка
# В последний день уходящего 2016 года Лимак собирается принять участие в соревновании по спортивному программированию.
# Соревнование начнётся в 20:00 и будет продолжаться четыре часа, то есть ровно до полуночи.
# Участникам будет предложено n задач, упорядоченных по возрастанию сложности, то есть задача 1 будет самой лёгкой,
# а задача номер n — самой сложной. Лимак знает, что ему потребуется 5·i минут на решение i-й задачи.
# Друзья Лимака планирую устроить роскошную новогоднюю вечеринку и Лимак хочет прибыть в полночь или ранее.
# Он знает, что ему требуется ровно k минут чтобы добрать до места проведения вечеринки от своего дома,
# где он собирается участвовать в соревновании.
# Сколько максимум задач может успеть решить Лимак, так чтобы не опоздать на новогоднюю вечеринку?
# Входные данные
# В первой строке входных данных записаны два целых числа n и k (1 ≤ n ≤ 10, 1 ≤ k ≤ 240) —
# количество задач в соревновании и количество минут, за которое Лимак доберётся от дома до места проведения вечеринки.
# Выходные данные
# Выведите одно целое число, равное максимальному количеству задач, которое может решить Лимак,
# так чтобы прибыть на новогоднюю вечеринку ровно в полночь или раньше.
n, k = map(int, input().split())
z = 240 - k   # время на решение задач
e = 0  # количество решенных задач
i = 1  # i счетчик.i*5 время на каждую последюющую задачу.
t = 0  # время потраченное на решение задач
while z >= 0 and n > 0 and t < z:
    n -= 1
    t = 5 * i
    z -= t
    e += 1
    i += 1
print(e)

#  Слияние списков
# В вашем распоряжении имеется два отсортированных списка по неубыванию элементов, состоящих из n и m элементов
# Ваша задача слить их в один отсортированный список размером  n + m
# Входные данные
# Программа получает на вход два числа n и m - количество элементов первого списка и второго списков
# Затем с новой строки поступают элементы первого отсортированного списка, а со следующей строки - второго списка
# Выходные данные
# Слить два списка в один в порядке неубывания и вывести элементы полученного списка
# P.S: пользоваться встроенной сортировкой запрещено
n, m = map(int, input().split())
a = list(map(int, input().split()))
b = list(map(int, input().split()))
c = []
i, j = 0, 0
while i < len(a) and j < len(b):
    if a[i] < b[j]:
        c.append(a[i])
        i += 1
    else:
        c.append(b[j])
        j += 1
c += a[i:]
c += b[j:]
print(' '.join(map(str, c)))

# Андроид Андреид — известный на всю галактику детектив. В свободное от работы время он размышляет о строках из нулей
# и единиц. Как-то раз ему в голову пришла строка длины n, состоящая из нулей и единиц. Рассмотрим следующую операцию
# — мы выбираем любые две соседние позиции в строке, и если в одной из них ноль, а в другой — единица, то разрешается
# удалить обе эти цифры, в результате чего строка строка становится длины n - 2.
# Андреид задумался — какой минимальной длины строка может остаться, если применить описанную операции некоторое
# (возможно, нулевое) количество раз?
# Входные данные
# В первой строке входных данных задано целое число n (1 ≤ n ≤ 2·105) — длина строки,
# которая пришла в голову Андреиду.
# Во второй строке записана строка длины n, состоящая из нулей и единиц.
# Выходные данные
# Выведите единственное целое число — минимальное возможное значение длины строки,
# которая останется после применения операций, описанных в условии задачи
n = int(input())  # длина стрки
m = list(str(input()))  # строка длины n
while "1" in m and "0" in m:
    m.remove('1')
    m.remove("0")
print(len(m))

# Система уравнений
# Фурик очень любит уроки математики, поэтому, в отличие от Рубика, он их не посещает.
# Но теперь Фурик хочет получить хорошую оценку по математике. Для этого Лариса Ивановна, учительница математики,
# дала ему новое задание. Фурик сразу же решил эту задачу, а вы сможете?
# Задана система уравнений:
# Нужно посчитать количество пар целых чисел (a, b) (0 ≤ a, b), которые удовлетворяют системе.
# Входные данные
# В единственной строке заданы два целых числа n, m (1 ≤ n, m ≤ 1000) — параметры системы. Числа в строке разделены пробелом.
# Выходные данные
# В единственную строку выведите ответ на задачу.


                                # Обход всех цифр числа с помощью while
# деситиричная система записи
x = int(input())
kol = 0
kol_ch = 0
s = 0
pr = 1
maxim = 0
minim = 9  # максимальное из числа
while x > 0:
    last = x % 10
    kol = kol +1
    if last % 2 == 0:
        kol_ch += 1
    s = s + last
    if last > maxim:
        maxim = last
    if last < minim:
        minim = last
    x = x // 10
print("Всего цифр:", kol)
print("Вскего чётных цифр:", kol_ch)
print("Сумма всех цифр:", s)
print("Произведение всех цифр:", pr)
print("Максимальное число", maxim)
print("Минимальное число", minim)
#  двоичная система записи
x = int(input())
while x > 0:
    last = x % 2
    print(last)
    x = x // 2
#   пятиричная система записи
x = int(input())
while x > 0:
    last = x % 5
    print(last)
    x = x // 5
# задачки
# Программа принимает на вход одно натуральное число и выводит на экран сумму цифр данного числа
x = int(input())
sam = 0
while x > 0:
    last = x % 10
    sam += last
    x = x // 10
print(sam)

# рограмма принимает на вход одно натуральное число и выводит на экран произведение цифр данного числа
x = int(input())
pr = 1
while x > 0:
    last = x % 10
    pr = pr * last
    x = x // 10
print(pr)
# Программа принимает на вход одно натуральное число. Ваша задачи найти сколько раз встречается цифра 7 в этом числе
x = int(input())
count = 0
while x > 0:
    last = x % 10
    if last == 7:
        count += 1
    x = x // 10
print(count)
                                    #  Алгоритм Евклида
# задачки по нахождению общего делителя
# Даны два натуральных числа A и B. Требуется найти их наибольший общий делитель (НОД) методом вычитания
a, b = map(int, input().split())
while a != b:
    if a > b:
        a = a - b
    else:
        b = b - a
print(a)
# Даны два натуральных числа A и B. Требуется найти их наибольший общий делитель (НОД) методом вычитания
a, b = map(int, input().split())
while b > 0:
    a, b = b, a % b
print(a)
# Даны два натуральных числа A и B. Требуется найти их наименьшее общее кратное (НОК).
a, b = map(int, input().split())
d, c = a, b
while b > 0:
    e = a, b = b, a % b
    NOK = int((c * d) / a)
print(NOK)
                           # Нахождение всех делителей числа
n = int(input())
i = 1
a = []
while i * i <= n:
    if n % i == 0:
        a.append(i)
        if i != n // i:
            a.append(n // i)
    i += 1
a.sort()
print(a)
                                        # нахождения НОК
a, b = 75, 120
i = min(a, b)
while True:
    if i % a == 0 and i % b == 0:
        break
    i += 1
print(i)
# задачки
# Дано натуральное число N.
# Определить, является ли оно простым.
# Натуральное число N называется простым, если у него есть только два делителя: единица и само число N.
# качестве ответа выведите "Yes", если число простое,  "No" - в противном случае.
n = int(input())
if 1 < n < 999999:
    i = 1  # делитель
    k = 1  # счётчик
    while i <= n:
        i += 1
        if n % i == 0:
            k += 1
    if k > 2:
        print('No')
    else:
        print('Yes')
else:
    print('No')
# Программа получает на вход натуральное число N.
# Нужно найти сумму его делителей.
n = int(input())
i = n
e = []
while i > 0:
    if n % i == 0:
        e.append(i)
    i -= 1
print(sum(e))
                                  # Инструкции break, continue, elsei = 1
while True:
    print("интерация", i)
    if i == 10:
        break
    i += 1
print('hello')
# пример
i = 1
while i <= 15:
    print(i)
    if i == 5:
        break
    i += 1
else:
    print("good")
    print("job")
print("end")

a = [54, 32, 65, 765, 32, 543]
# Yes - все чётные
# No - в противном случае
while len(a) > 0:
    last = a.pop()
    if last % 2 != 0:
        print("No", last)
        break
else:
    print("Yes")
# заменяем все числа на чётные
# задачка
# Гипотеза Коллатца
# Сиракузская последовательность, или последовательность Коллатца, строится так:
# возьмём натуральное число n; если оно чётное, то заменим его числом n/2; если же оно нечётное,
# то заменим его числом 3n+1. Получившееся число — следующее в сиракузской последовательности после числа n.
# Затем заменяем получившееся число по тому же правилу, и так далее.
# Определите, сколько шагов потребуется сиракузской последовательности, стартующей с заданного числа, чтобы прийти к 1.
# Обычно, если проделать такую замену достаточно много раз, мы приходим к числу 1 (за которым следует снова 1).
# Например:
# 8 → 4 → 2 → 1 или 10 → 5 → 16 → 8 → 4 → 2 → 1.
# Определите, сколько шагов потребуется сиракузской последовательности, стартующей с заданного числа, чтобы прийти к 1.
# Если вы обнаружите число, сиракузская последовательность от которого не приходит к 1, то... вы, скорее всего, ошиблись
# Но если нет, то поздравляем: вы прославитесь, ведь вопрос о том,
# всегда ли сиракузская последовательность приходит к 1(независимо от начального числа), давно будоражит умы математиков
# Формат ввода
# Вводится одно натуральное число n.
# Формат вывода
# Выводится одно число — количество шагов, необходимое стартующей от n сиракузской последовательности,
# чтобы впервые дойти до 1.
n = int(input())
i = 0
while True:
    if n == 1:
        break
    if n % 2 == 0:
        n = n / 2
        i += 1
    else:
        n = 3 * n + 1
        i += 1
print(i)
# Система уравнений
# Фурик очень любит уроки математики, поэтому, в отличие от Рубика, он их не посещает.
# Но теперь Фурик хочет получить хорошую оценку по математике.
# Для этого Лариса Ивановна, учительница математики, дала ему новое задание.
# Фурик сразу же решил эту задачу, а вы сможете?
# Задана система уравнений:
# Нужно посчитать количество пар целых чисел (a, b) (0 ≤ a, b), которые удовлетворяют системе.
# Входные данные
# В единственной строке заданы два целых числа n, m (1 ≤ n, m ≤ 1000) — параметры системы.
# Числа в строке разделены пробелом.
# Выходные данные
# В единственную строку выведите ответ на задачу.
n, m = map(int, input().split())
count = 0
a = 0
while a ** 2 <= n:
    b = n - a ** 2
    if b >= 0 and a + b ** 2 == m:
        count += 1
    a += 1
print(count)